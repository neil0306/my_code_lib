# 题目
LeetCode 1. 两数之和
- https://leetcode.cn/problems/two-sum/description/

```txt
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
    你可以按任意顺序返回答案。

示例 1：
    输入：nums = [2,7,11,15], target = 9
    输出：[0,1]
    解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：
    输入：nums = [3,2,4], target = 6
    输出：[1,2]

示例 3：
    输入：nums = [3,3], target = 6
    输出：[0,1]

提示：
    2 <= nums.length <= 10^4
    -10^9 <= nums[i] <= 10^9
    -10^9 <= target <= 10^9
    只会存在一个有效答案
```

# 思路
这道题可以理解为:  
- 数组中**是否存在两个数**, 使得这两个数的和等于目标值.
  - 问`是否存在`或者`是否出现过`, 这种题目一般用`哈希法`解决.

```txt
哈希法一般可以用下面三种数据结构:
1. 数组
2. set
3. map (key-value)

在本题中, 数组由于不能随意扩大或缩小, 所以就会出现空间浪费严重或者空间不足的情况. 不适合.
对于 set, 由于题目要求返回元素的下标, 所以如果只能存存储一个值的话, 难以外完成这个任务, 不适合.
对于map, 需要考虑什么作为 key, 什么作为 value.
    1. key: 数组中的值
    2. value: 数组中的下标
```

需要注意:
```txt
1. 数组只能用一次, 并且不能重复使用.

2. nums数组中存在重复元素, 想要避免因为重复元素的添加导致的下标覆盖, 这里采用的方案是:
    - 只添加遍历过的元素, 未遍历过的元素不添加. 
        - 由于提示中明确: 只存在一组答案, 那么那些不是答案的元素下标被覆盖也不影响最终答案.

```

## 代码
```cpp
vector<int> twoSum(vector<int>& nums, int target) 
{
    unordered_map<int, int> map_nums;       // 存放元素在数组中的位置
    for(int i = 0; i < nums.size(); ++i){
        // 如果在哈希表中找到了另一个元素
        if(map_nums.find(target - nums[i]) != map_nums.end()){
            return {i, map_nums[target - nums[i]]};
        }
        
        // 如果哈希表中没有这个元素, 则把遍历过的当前元素放入哈希表
        map_nums[nums[i]] = i;
    }
    return {};
}
```