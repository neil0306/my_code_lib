# 题目

LeetCode 49 字母异位词分组
- https://leetcode.cn/problems/group-anagrams/description/

```txt
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
    字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

示例 1:
    输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
    输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

示例 2:
    输入: strs = [""]
    输出: [[""]]

示例 3:
    输入: strs = ["a"]
    输出: [["a"]]

提示：
    1 <= strs.length <= 10^4
    0 <= strs[i].length <= 100
    strs[i] 仅包含小写字母
```


# 思路
## 方法1: 
由于字母异位词在排序后是相同的字符串, 故对每个单词先排序, 然后以排序后的单词作为key丢到哈希表的value里, 最后遍历整个哈希表, 将每个 value 存储到 result 中进行返回即可.
- 由于排序并不是主要考点, 所以大概率是允许用内置排序函数的.


### 代码实现
```cpp

```


## 方法2: 用质数映射字母, 把字母异位词映射成相同的质数乘积
这是美版LeetCode大佬的骚操作...

使用`质数`表示每一个字母，然后相乘，**这样就可以保证每一个字母异位词的乘积是相同的**，然后使用`unordered_map`进行存储，最后将`unordered_map`中的`value`值存储到`vector`中即可。

### 代码实现
```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) 
{
    unordered_map <char, int> AlphToPrimeMap;       // 字母到质数的映射
    // 为了防止过大, 还专门优化了一下质数的使用顺序, 出现频次大的字母, 用小质数, 防止溢出
    int primeNum[26] = {5, 71, 31, 29, 2, 53, 59, 23, 11, 89, 79, 37, 41, 13, 7, 43, 97, 17, 19, 3, 47, 73, 61, 83, 67, 101};
    for (int i = 0; i < 26; i++)
    {
        AlphToPrimeMap[i + 'a'] = primeNum[i];
    }

    // 开始计算字符串的字母数字乘积
    unordered_map <unsigned int, vector<string> > mp;
    unsigned int key = 1;
    for (int i = 0; i < strs.size(); i++)       // 遍历每一个字母
    {
        key = 1;
        for (int j = 0; j < strs[i].size(); j++)
        {
            key *= AlphToPrimeMap[strs[i][j]];
        }
        mp[key].push_back(strs[i]);             // 以所有字母对应的质数成绩作为 key, 将字符串存储到对应的 value 中
    }

    // 输出结果
    vector<vector<string> > res;
    for (auto it = mp.begin(); it != mp.end(); it++)        // 遍历 unordered_map, 将 value 存储到 vector 中
    {
        res.push_back(it->second);                          // it->second 是一个 vector<string>, 对应 value 字段
    }
    return res;
}
```











