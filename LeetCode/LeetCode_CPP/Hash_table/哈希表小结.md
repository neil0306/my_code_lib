# 基础知识
[哈希表基本知识点](https://github.com/neil0306/Data-Structure-in-C/blob/9e711926f56f67717d217146b9bfedd164d0be09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%9F%A5%E6%89%BE/%E6%9F%A5%E6%89%BE_%E5%93%88%E5%B8%8C%E8%A1%A8.md#L1)可以看之前数据结构的笔记.

知识点主要包括:
```txt
1. 哈希函数选取
2. 哈希冲突的处理
```

## 常见的三种哈希结构
在需要使用哈希法解决问题时, 一般都会考虑以下三种数据结构:
```txt
1. 数组
2. set(集合)
3. map(映射)
```
对于数组:
- 数组是最简单的一种哈希结构, 但是数组的缺点是不能动态扩容.

对于set和map:
- 在C++中, `set`提供了下面三种数据结构, 对应的底层和优劣如下表所示

    | 集合                | 底层实现    | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率  | 增删效率  |
    |---------------------|-------------|----------|------------------|-------------|-----------|-----------|
    | std::set            | 红黑树      | 有序     | 否               | 否          | O(log n)  | O(log n)  |
    | std::multiset       | 红黑树      | 有序     | 是               | 否          | O(log n)  | O(log n)  |
    | std::unordered_set  | 哈希表      | 无序     | 否               | 否          | O(1)      | O(1)      |

  - `std::unordered_set`底层实现为**哈希表**，`std::se`t 和`std::multiset` 的底层实现是**红黑树**，红黑树是一种[平衡二叉搜索树](https://github.com/neil0306/Data-Structure-in-C/blob/9e711926f56f67717d217146b9bfedd164d0be09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%9F%A5%E6%89%BE/%E6%9F%A5%E6%89%BE_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md)，所以**key值是有序**的，但**key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加**。
  - 当我们要使用集合来解决哈希问题的时候，**优先使用**`unordered_set`，因为它的查询和增删效率是最优的，如果需要集合是**有序**的，那么就用`set`，如果要求**不仅有序还要有重复数据**的话，那么就用`multiset`。

- 类似地, `map`在C++中也有如下三种结构:
    | 映射                   | 底层实现         | 是否有序 | 数值是否可以重复 | 能否更改数值   | 查询效率  | 增删效率  |
    |------------------------|------------------|----------|------------------|--------------|-----------|-----------|
    | std::map               | 红黑树           | 有序     | 否               | 否           | O(log n)  | O(log n)  |
    | std::multimap          | 红黑树           | 有序     | 是               | 否           | O(log n)  | O(log n)  |
    | std::unordered_map     | 哈希表           | 无序     | 否               | 否           | O(1)      | O(1)      |
    - `std::unordered_map` 底层实现为**哈希表**，`std::map` 和`std::multimap` 的底层实现是**红黑树**。同理，std::map 和std::multimap 的**key也是有序的** (这个问题也经常作为面试题，考察对语言容器底层的理解)。
    - map 是一个key-value 的数据结构，**map中，对key是有限制，对value没有限制的**，因为key的存储方式使用红黑树实现的。


- 虽然 std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

- 一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？
  - 实际上功能都是一样一样的， 但是`unordered_set`**在C++11的时候被引入标准库了**，而**hash_set并没有**，所以建议还是使用unordered_set比较好.


**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。**
