# 栈与队列的基础知识
栈与队列在使用上的区别:
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png)
- 栈是`先进后出(First In Last Out, FILO)`, 队列是`先进先出(First In Fist Out, FIFO)`

--- 
## 关于STL中的栈
对于栈, 有如下几个问题需要明确:
1. C++中stack 是容器么？
    ```txt
    栈和队列都是C++里 (SLT) 的两种数据结构.
        他们确实是一种容器.
    ```

2. 我们使用的stack是属于哪个版本的STL？
    ```txt
    HP STL:
        其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且**开放源代码**。

    P.J.Plauger STL:
        由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，**不是开源的**。

    SGI STL:
        由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，**SGI STL是开源软件**，源码可读性甚高。

    接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。
    ```

3. 我们使用的STL中stack是如何实现的？
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235434905.png)

4. stack 提供迭代器来遍历stack空间么？
    ```txt
    栈提供push 和 pop 等等接口，所有元素必须符合 **先进后出** 规则.
        所以 **栈不提供走访功能**，也 **不提供迭代器(iterator)**。

    set 或者 map 这种数据结构则会提供迭代器iterator来遍历所有元素。
    ```
   - 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们**可以控制使用哪种容器来实现栈的功能**）。

   - 所以STL中栈往往**不被归类为容器**，而`被归类为container adapter(容器适配器)`


栈的内部结构，栈的底层实现可以是`vector`，`deque`，`list` 都是可以的，**主要就是数组和链表的底层实现**。
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235459376.png)

- 我们常用的SGI STL，如果没有指定底层实现的话，`默认是以deque为缺省情况下栈的底层结构`。
  - deque是一个**双向队列**，只要封住一端，只开通另一端就可以实现栈的逻辑了。

指定使用`vector`初始化stack的语句为:
```cpp
std::stack<int, std::vector<int>> stack_test; // 使用vector作为底层容器
```

## 关于队列
SGI STL 中, `队列`底层实现`缺省情况下与stack一样, 都使用deque实现`。

指定使用`vector`初始化queue的语句为:
```cpp
std::queue<int, std::vector<int>> queue_test; // 使用vector作为底层容器
```
- 所以STL 队列也不被归类为容器，而被归类为`container adapter(容器适配器)`。


# 经典面试题
## 栈里的元素在内存中是连续分布的吗
```cpp
陷阱1:
    栈是'容器适配器', 底层可以更换不同的容器, 因此, 栈内的数据在内存中是'不一定'连续分布的. 

陷阱2:
    默认的情况下, 默认使用的底层容器是 deque(双端队列)
        而双端队列在内存中是'不连续的'的!
```

## 栈在系统中的应用
linux中的`cd`命令, 在解析`../`这种路径时, 就需要使用栈进行弹出.
- LeetCode 71. 简化路径
  - 核心思路是遇到 `..`的时候就出栈一次.

## 括号匹配问题
括号匹配一般都使用`栈`来处理, 将时间复杂度从`O(n^2)`降低到`O(n)`.

## 字符串去重
思路就是可以`把字符串顺序放到一个栈中`，然后**如果相同的话 栈就弹出**，这样最后栈里剩下的元素都是相邻不相同的元素了。

## 逆波兰表达式
将中缀表达式转换为`逆波兰表达式(后缀表达式)`, 一般使用二叉树的后序遍历来实现.

将后缀表达式求解, 一般使用`栈`, 核心思想是遇到运算符时, 就依次弹出两个元素, 第一个元素是右操作数, 第二个元素是左操作数, 然后进行运算, 将结果压入栈中.
- 字符转换为整数, 可以使用内置的`stoi (string to int)`, 或者直接 `int = s[i]`来实现(使用基本数据类型的隐式转换), 但是这种方式不够安全.


## 滑动窗口的最大值
需要使用`优先级队列`实现, 它本质上是一个`最大堆/最小堆`, 也就是一个`完全二叉树`, 在使用时需要定义一个`函数符`, 用来比较两个元素的大小(同时也是指定优先级队列是最大堆还是最小堆的手段). 
```cpp
这个题目的主要思想是队列'没有必要维护窗口里的所有元素'，'只需要维护有可能成为窗口里最大值的元素'就可以了，同时保证队列里的元素数值是由大到小的。

那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来一个单调队列.
    设计单调队列的时候，pop，和push操作要保持如下规则：
        pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作

        push(value)：如果push的元素value大于入口元素的数值，那么就将队列出口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止

        需要注意的是, 这种pop和push的规则'仅适用于本题'.
            单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。
```

## 求前k个高频元素
这个题也需要使用优先级队列来实现, 而且在此之前, 需要先统计每个元素出现的次数, 这里可以使用`哈希表`来实现.
- 并且对于本题来说, 因为只需要找到前k个高频元素, 所以我们的优先级队列只需要维持k个元素即可.
  - 排序的过程的时间复杂度是 $O(\log k)$ ，整个算法的时间复杂度是 $O(n\log k)$


