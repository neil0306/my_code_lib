# 链表基础知识回顾

## 链表的定义
链表头指针 head:
- 链表的表头指针 `head` 本质上是一个`指针变量`, 它宛如一个`索套`一样的东西, 套到哪个节点(指针里存放什么地址), 就能任意操作这个节点里的东西. 
  - 由此, head 这个指针本身也等同于链表的第一个节点, 可以理解为head就是链表第一个节点, 他们是同一个东西.

单链表
```txt
链表节点只包含两个部分:
    1. 数据域
    2. 指针域
        只有一个指针, 指向链表的下一个节点

单链表只能单向查询.
```

双链表
```txt
与单链表的区别是指针域多了一个指针, 一共有两个指针:
    1. 指向链表的上一个节点
    2. 指向链表的下一个节点

数据域依然只有1个.

双链表可以双向查询.
```

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png)


循环链表
```txt
只要是"首尾相连"的链表, 就是循环链表.
```
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png)


链表的存储方式
- 内存中不连续, 节点存储的位置由系统分配
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png)

链表的定义
```cpp
struct LinkedListNode {
    int val;
    LinkedlistNode *next;
    LinkedlistNode(int x) : val(x), next(NULL) {}       // 构造函数
};
```
- `不写构造函数也可以`, C++会自动创建一个默认的构造函数. 
  - 如果不写构造函数, 那么在声明一个链表节点的时候就不能直接进行初始化, 而是需要先声明一个节点, 然后再进行初始化.
    ```cpp
    // 有构造函数的情况
    LinkedListNode * head = new LinkedListNode(0);

    // 无构造函数的情况
    LinkedListNode * head;
    head->val = 0;
    ```


## 链表的基本操作
- 删节点
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png)
  - 在C++中, 需要注意手动释放删掉的节点的内存块.
    ```cpp
    LinkedListNode * temp = head->next;
    head->next = head->next->next;
    delete temp;            // 释放内存
    ```
    - 时间复杂度为`O(1)`, 删除的过程是直接干掉新节点 (寻找节点的过程不在计时范围里, 这属于查找操作)

- 增节点
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png)

- 查找
  - 查找的时候需要逐个节点进行遍历, 所以时间复杂度为`O(n)`.
  - 时间复杂度为`O(1)`, 新增的过程是直接插入新节点 (寻找节点的过程不在计时范围里, 这属于查找操作)

链表与数组的性能对比
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

----


# 关于链表的典型考点

## 知识点: 虚拟头结点 (dummy head)
在进行[删除节点](../Linked_list/Remove_LinkList_element/203/题解.md)或[查找链表相交位置](../Linked_list/Intersection_of_two_linklist/160/题解.md)时, 虚拟头结点就是一个非常好用的技巧:
- 对于删除节点来说, 我们总是需要找到`待删节点的前趋点`, 然后再执行删除操作. 此时, **对于头结点来说**, 就尴尬了, 链表的第一个节点缺少一个存放它内存地址的独立的节点, 如果不使用虚拟头结点, 我们就需为头结点的删除单独进行考虑, 费时费力.
  - 虚拟头结点则是损失一个节点的存储空间, 但是极大方便了代码的编写, 投资回报率很高.

虚拟头结点 与 常规 head指针 之间的区别:
- head指针在[前面](#链表的定义)提到过, 它是类似"索套"一样的东西, 它本身并不是一个独立的链表节点, 它只是一个指针变量, 里面存放着链表的第一个节点的内存地址.
- 虚拟头结点则是一个`独立的链表节点`, 它里面既有数据域, 也有指针域, 并且指针域里面存放着原链表的第一个节点的内存地址.

## 考点: 链表基本操作
在[设计链表](../Linked_list/Design_linked_list/707/题解.md)这道题里就考察了下面5种基本操作:
```txt
1. 获取链表第index个节点的数值
2. 在链表的最前面插入一个节点
3. 在链表的最后面插入一个节点
4. 在链表第index个节点前面插入一个节点
5. 删除链表的第index个节点的数值
```

## 考点: 反转链表
[反转链表](../Linked_list/Reverse_linked_list/206/题解.md)考察的其实就相当于是考察`头插法`, 借助虚拟头结点, 我们不断将链表未反转的第一个节点**插入到虚拟头结点的前面**, 完整所有节点都插入到虚拟头结点之前这个动作后, 虚拟头结点的next指针存放的就是反转后的链表了.

## 考点: 删除倒数第N个节点
[删除链表倒数第n个节点](../Linked_list/Remove_nth_node_from_end/19/题解.md)本质上考察的是双指针法(快慢指针), 要删除倒数第n个节点, 只需要先让快指针走遍历n步, 然后再同时移动快指针和慢指针, 当 `fast == nullptr` 时, `slow 刚好走到待删除节点的前趋点位置`, 这时候直接执行删除节点操作即可. 

## 考点: 链表相交
[链表相交](../Linked_list/Intersection_of_two_linklist/160/题解.md)需要特别注意相交节点是`内存地址相同`而不是节点的数据相同.

## 考点: 环形链表
[环形链表](../Linked_list/Linked_list_cycle/142/题解.md)应该是链表考点里最复杂的一种, 需要进行公式推导, 并简化公式, 再得到最终解题方案.


# 链表小结思维导图
![](https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png)