# 链表基础知识回顾

## 链表的定义
单链表
```txt
链表指点只包含两个部分:
    1. 数据域
    2. 指针域
        只有一个指针, 指向链表的下一个节点

单链表只能单向查询.
```

双链表
```txt
与单链表的区别是指针域多了一个指针, 一共有两个指针:
    1. 指向链表的上一个节点
    2. 指向链表的下一个节点

数据域依然只有1个.

双链表可以双向查询.
```

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png)


循环链表
```txt
只要是"首尾相连"的链表, 就是循环链表.
```
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png)


链表的存储方式
- 内存中不连续, 节点存储的位置由系统分配
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png)

链表的定义
```cpp
struct LinkedListNode {
    int val;
    LinkedlistNode *next;
    LinkedlistNode(int x) : val(x), next(NULL) {}       // 构造函数
};
```
- `不写构造函数也可以`, C++会自动创建一个默认的构造函数. 
  - 如果不写构造函数, 那么在声明一个链表节点的时候就不能直接进行初始化, 而是需要先声明一个节点, 然后再进行初始化.
    ```cpp
    // 有构造函数的情况
    LinkedListNode * head = new LinkedListNode(0);

    // 无构造函数的情况
    LinkedListNode * head;
    head->val = 0;
    ```


## 链表的基本操作
- 删节点
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png)
  - 在C++中, 需要注意手动释放删掉的节点的内存块.
    ```cpp
    LinkedListNode * temp = head->next;
    head->next = head->next->next;
    delete temp;            // 释放内存
    ```
    - 时间复杂度为`O(1)`, 删除的过程是直接干掉新节点 (寻找节点的过程不在计时范围里, 这属于查找操作)

- 增节点
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png)

- 查找
  - 查找的时候需要逐个节点进行遍历, 所以时间复杂度为`O(n)`.
  - 时间复杂度为`O(1)`, 新增的过程是直接插入新节点 (寻找节点的过程不在计时范围里, 这属于查找操作)

链表与数组的性能对比
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

----


