# 题目
LeetCode 844: 比较含退格的字符串

```txt
给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。
    注意：如果对空文本输入退格字符，文本继续为空。

示例 1：
    输入：s = "ab#c", t = "ad#c"
    输出：true
    解释：s 和 t 都会变成 "ac"。

示例 2：
    输入：s = "ab##", t = "c#d#"
    输出：true
    解释：s 和 t 都会变成 ""。

示例 3：
    输入：s = "a#c", t = "b"
    输出：false
    解释：s 会变成 "c"，但 t 仍然是 "b"。

提示：
    1 <= s.length, t.length <= 200
    s 和 t 只含有小写字母以及字符 '#'

进阶：
    你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？
```


# 思路
匹配问题一般用`栈`来做会比较顺手, 但是这里要求空间复杂度为O(1), 所以暂时不考虑用栈来做.

核心思想:
- 这里依然考虑双指针, 但是这里的双指针不是指向同一个数组, 而是指向两个字符串,
  - 遍历时, 从`后往前遍历`, 遇到`#`就跳过, 遇到非`#`就比较两个指针指向的字符是否相等.
    - 需要特别小心`a#c#`这种不连续的井号, 但是处理的时候又需要连续退格的情况.


## 核心代码
```cpp
bool backspaceCompare(string s, string t) {
    int i = s.length() -1, j = t.length() -1;   // 双指针, 从末尾开始遍历
    int cnt_s = 0, cnt_t = 0;                           // 记录某个区间内#号个数 

    while(true){

        // 干掉s里的井号, 注意处理 "a#c#" 这种情况, 井号不连续出现, 但是处理的时候其实需要连续退格的
        while(i >= 0){
            if(s[i] == '#'){
                cnt_s++;
            }
            else{
                // 处理退格
                if(cnt_s > 0){
                    cnt_s--;    // 每次循环退格一次
                }
                else{
                    break;      // 当前区域退格完成, 跳出这层while
                }
            }
            i--;
        }

        // 处理t字符串的井号
        while(j >= 0){
            if(t[j] == '#'){
                cnt_t++;
            }
            else{
                // 处理井号的退格
                if(cnt_t > 0){
                    cnt_t--;    // 每次循环退格一次
                }
                else{
                    break;      // 当前区域退格完成, 跳出这层while
                }
            }
            j--;
        }
    
        // 如果其中一个字符已经遍历到字符串开头, 跳出整个循环
        if(i < 0 || j < 0){
            break;
        }

        // 处理完退格, 开始比较字符串(此时比较的是末尾的有效字符), 只要有一个字符不同, 就结束
        if(s[i] != t[j]){
            return false;
        }

        // 走到这里, 证明进行了退格之后的第一个有效字符是相等的, 继续往字符串开头方向更新
        i--;
        j--;
    }

    if(j == -1 && i == -1){  // 同时遍历完, 说明相等
        return true;
    }

    return false;           // 其中一个字符串提前遍历结束时, 返回false
}
```