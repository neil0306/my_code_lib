# 题目
LeetCode 904. 水果成篮
- https://leetcode.cn/problems/fruit-into-baskets/
```txt
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
    你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。

    你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。

    一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

    给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。

示例 1：
    输入：fruits = [1,2,1]
    输出：3
    解释：可以采摘全部 3 棵树。

示例 2：
    输入：fruits = [0,1,2,2]
    输出：3
    解释：可以采摘 [1,2,2] 这三棵树。
    如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。

示例 3：
    输入：fruits = [1,2,3,2,2]
    输出：4
    解释：可以采摘 [2,3,2,2] 这四棵树。
    如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。

示例 4：
    输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
    输出：5
    解释：可以采摘 [1,2,1,1,2] 这五棵树。

提示：
    1 <= fruits.length <= 10^5
    0 <= fruits[i] < fruits.length
```

# 思路
翻译成人话: `从给定的数组中, 找至多包含两种元素的最长子串，返回其长度`.

这道题考的是数组, 一般首先尝试双指针, 这题又恰好符合滑动窗口的特征, 所以可以考虑滑动窗口解决.

关于滑动窗口, 一般需要注意3个问题:
```txt
1. 窗口里是什么?
2. 窗口左边界怎么移动?
3. 窗口右边界怎么移动?
```

- 对于这道题, 回答是:
    ```txt
    1. 窗口里包含至多两种数字
    2. 当窗口里包含的数字种类超过两种时, 左边界需要移动, 直到窗口里的数字种类小于等于两种
    3. 右边界随着数组的遍历每次往右边移动一位
        - 注意这是题目本身就要求的: "每采摘一次，你将会向右移动到下一棵树，并继续采摘。"
    ```

除此之外, 由于我们希望能记录窗口内部的数字种类, 所以需要一个数据结构来记录窗口内部的数字种类, 这里可以使用哈希表 `unordered_map<int, int>`.
- 值得留意的是, 此时的`unordered_map<int, int>`没有进行自定义赋值的初始化时, 都会默认用`0初始化`. 

## 代码
核心代码:
```cpp
int totalFruit(vector<int> & fruits)
{
    int res = 0;
    int f_size = fruits.size();
    int valid = 0;                  // 用于记录窗口中种类的数量 

    int left = 0, right = 0;        // 窗口左右边界
    unordered_map<int, int> window; // 哈希表(python的字典), 用来记录不同元素的个数

    while(right < f_size){   // 遍历数组 & 右边界移动方式
        int fruit_a = fruits[right];

        // 如果进来的是新元素: 在哈希表中创建新 key-value; 元素种类+1
        if(window[fruit_a] == 0){
            valid++;
        }
        // 不管是不是新种类, 总数都+1
        window[fruit_a]++;

        // 检查种类数量, 不满足窗口条件就从窗口左侧开始依次弹出元素 (窗口左边界移动方式)
        while(valid > 2){
            int fruit_b = fruits[left];
            window[fruit_b]--;

            // 如果当前窗口已经没有水果种类, 则种类-1
            if(window[fruit_b] == 0){
                valid--;
            }

            // 移动左边界 
            left++;
        }

        // 移动右边界, 遍历下一个元素
        right++;
    
        res = max(res, right - left);
        // debug
        // cout << "res: " << res << endl;
        // show_window(fruits, left, right);
    }
    return res;
}
```
