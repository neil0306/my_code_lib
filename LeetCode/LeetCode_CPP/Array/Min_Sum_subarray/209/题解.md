# 题目
LeetCode 209. 长度最小的子数组
- https://leetcode.cn/problems/minimum-size-subarray-sum/

```txt
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：
    输入：s = 7, nums = [2,3,1,2,4,3]
    输出：2
    解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：
    1 <= target <= 10^9
    1 <= nums.length <= 10^5
    1 <= nums[i] <= 10^5
```

# 思路
遇到数组, 一般想到的是`双指针`, 但是这道题目, 有点特殊, 因为数组中的元素都是正整数(不一定有序), 所以可以用滑动窗口的思想来解决.

## 滑动窗口
滑动窗口其实也是在使用`双指针`, 只不过此时的左右指针分别代表了一个窗口的左右边界, 并且每次移动的时候, 相当于窗口在进行整体移动(包含缩放).

使用滑动窗口需要注意分析以下3点:
```txt
1. 窗口里面装的是什么? (构成窗口的条件)
2. 窗口的左边界(起始位置)什么时候移动? 如何移动?
3. 窗口的右边界(终止位置)什么时候移动? 如何移动?
```

在这道题中, 针对上面三点的回答是:
```txt
1. 窗口内要保证元素的和 >= s
2. 当窗口内元素的和 >= s 时, 左边界开始移动, 直到窗口内元素的和 < s
3. 窗口的右边由遍历数组的指针控制, 每次遍历到一个元素, 就将其加入到窗口中, 并判断窗口内元素的和是否 >= s
```

动图演示:
![](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

于是有:
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210312160441942.png)


# 代码实现
核心代码:
```cpp
int minSubArrayLen(int target, vector<int>& nums) {
    int sum = 0;
    int i = 0, j = 0;               // 窗口左边界

    // 题目中提到最长是10^5
    int tempLen = 0;              // 记录窗口宽度  
    int res = INT32_MAX;          // 最终结果 (用一个很大的数来填充, 确保逻辑正确)

    // 窗口右边界 & 移动方式
    for (int j = 0; j < nums.size(); j++){
        // 窗口内容
        sum += nums[j];             // 每遍历一个元素就加入窗口内, 窗口里放的是元素之和

        // 窗口左边界 & 移动方式
        while(sum >= target){       // 能进while, 说明窗口元素满足条件 
            tempLen = (j - i + 1);   // 计算当前子序列长度
            res = res < tempLen ? res : tempLen;

            // 记录好当前子序列之后, 开始尝试缩小窗口, 如果仍满足窗口条件, 会再次进入while
            sum -= nums[i];
            i++;
        }
    }
    return res == INT32_MAX ? 0 : res;
}
``

