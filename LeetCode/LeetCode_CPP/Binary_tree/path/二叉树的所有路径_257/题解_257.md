# 题目
Leetcode 257. 二叉树的所有路径
- https://leetcode.cn/problems/binary-tree-paths/description/

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

示例 1：
```txt
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

示例 2：
```txt
输入：root = [1]
输出：["1"]
```

提示：
```txt
树中节点的数目在范围 [1, 100] 内
-100 <= Node.val <= 100
```


# 思路
这道题需要使用`二叉树的前序遍历`来完成, 一边遍历一边记录当前遍历到的节点, 在遍历到叶子节点后, 将记录的节点转成输出要求的字符串格式.
- 递归中一层层往回走的过程其实就是`回溯`思想.

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151702443.png)

# 代码 - 递归

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void traversal(TreeNode* cur, vector<int>& path, vector<string>& res)       // path用vector是为了方便回溯
    {
        path.push_back(cur->val);       // 中

        // 递归停止条件: 遇到叶子节点 (而不是直接写 cur==nullptr, 因为此时的处理会特别麻烦, 判断空节点的任务可以交给单次递归逻辑)
        if(cur->left == nullptr && cur->right == nullptr){
            string subPath; 
            for(int i = 0; i < path.size()-1; ++i){
                subPath += to_string(path[i]);
                subPath += "->";
            }
            subPath += to_string(path[path.size()-1]);      // 最后一个节点
            res.push_back(subPath);
            return;
        }

        // 单次递归逻辑
        if(cur->left != nullptr){       // 左
            traversal(cur->left, path, res);
            path.pop_back();        // 回溯(回溯紧挨着递归!): 弹出当前节点
        }
        if(cur->right != nullptr){     // 右
            traversal(cur->right, path, res);
            path.pop_back();
        }
        return;
    }

    vector<string> binaryTreePaths(TreeNode* root) 
    {
        vector<int> path;
        vector<string> res;

        if(root == nullptr){
            return res;
        }

        traversal(root, path, res);
        return res;
    }
};
```

## 精简版
```cpp
class Solution
{
private:
    void traversal(TreeNode * cur, string path, vector<string>& res)
    {
        path += to_string(cur->val);        // 中

        // 递归停止条件
        if(cur->left == nullptr && cur->right == nullptr){
            res.push_back(path);
            return;
        }

        // 单次递归逻辑
        if(cur->left != nullptr){
            traversal(cur->left, path + "->", res);     // 隐藏了回溯的过程(因为path没有用到vector, 当前节点只会记录一次)
        }
        if(cur->right != nullptr){
            traversal(cur->right, path + "->", res);
        }
        return;
    }
public:
    vector<string> binaryTreePaths(TreeNode * root)
    {
        vector<string> res;
        string path;
        if(root == nullptr){
            return res;
        }
        traversal(root, path, res);
        return res;
    }
};
```
