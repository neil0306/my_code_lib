# 二叉树基础知识
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219190809451.png)
## 二叉树的种类

在解题过程中, 主要用到的二叉树是`满二叉树`和`完全二叉树`

### 满二叉树
二叉树中，节点的`度`指的是结点拥有的`子树的数目`。
- 而整棵树的度指的是树中**结点的最大的度**。

满二叉树：
- 如果一棵二叉树**只有**`度为0的结点`和`度为2的结点`，并且**度为0的结点在同一层上**，则这棵二叉树为满二叉树。
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png)
  - 这棵二叉树为`满二叉树`，也可以说`深度为k`(k为层数, 这棵树有4层, k为4)，有 $2^k-1$ 个节点的二叉树。



### 完全二叉树
完全二叉树的定义为:
```cpp
在完全二叉树中，除了'最底层节点可能没填满'外，其余'每层节点数都达到最大值'，
并且最下面一层的节点都集中在该层'最左边'的若干位置。

若最底层为第 h 层（h从1开始），则该层包含 1 ~ 2^(h-1) 个节点。
```
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png)



### 二叉搜索树
前面的[满二叉树](#满二叉树)和[完全二叉树](#完全二叉树)都是没有数值的, 但是二叉搜索树是**有数值**的, 并且**二叉搜索树是一颗有序树**.
- 由于二叉搜索树是有序的，所以它的遍历方式 99.99% 都是`中序遍历`.
```cpp
对于一颗'二叉搜索树'而言: 
    若它的左子树不空，则左子树上所有结点的值均'小于'它的根结点的值；
    
    若它的右子树不空，则右子树上所有结点的值均'大于'它的根结点的值；
    
    它的左、右子树也分别为二叉搜索树.
```


### 平衡二叉搜索树 (AVL)
平衡二叉搜索树也称为AVL树(Adelson-Velskii-Landi Tree), 它是一种**自平衡二叉搜索树**.
- 性质:
  - 一棵空树或它的左右两个子树的`高度差的绝对值不超过1`，并且`左右两个子树都是一棵平衡二叉树`.

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png)
- 第三棵树的左右子树高度差大于1了, 所以不是平衡二叉搜索树.

```cpp
C++中 'map'、'set'、'multimap'，'multiset' 的底层实现都是'平衡二叉搜索树'，
    所以 map、set 的 增删操作 时间时间复杂度是 log(n)

unordered_map、unordered_set，unordered_map、unordered_set 底层实现是'哈希表'。
```

## 二叉树的存储方式
二叉树可以使用`链式存储`和`顺序存储`两种方式来存储。
- 链式存储指的是`链表`
  ![链表的存储方式](https://code-thinking-1253855093.file.myqcloud.com/pics/2020092019554618.png)
- 顺序存储指的是`数组`
  ![数组的存储方式](https://code-thinking-1253855093.file.myqcloud.com/pics/20200920200429452.png)
    - 对于数组的存储方式:
        ```txt
        如果父节点的数组下标是 i，那么它的
            左孩子就是 i * 2 + 1，
            右孩子就是 i * 2 + 2。
        ```


## 区分几种二叉树
平衡二叉搜索树是不是二叉搜索树和平衡二叉树的结合？
>是的，是二叉搜索树和平衡二叉树的结合。

平衡二叉树与完全二叉树的区别在于底层节点的位置？
>是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。

堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？
>**堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树**。


## 二叉树的遍历方式
主要分为两个大类:
- 深度优先: 先往树的深处走, 遇到叶子节点再往回走(也就是没有子树的节点)
- 广度优先: 一层层地遍历.

### 深度优先遍历
根据`根节点的遍历顺序`进一步分为:
```txt
前序遍历
    根节点最先遍历, 顺序为 中->左->右
    遍历的方法是: 递归法 + 迭代法
中序遍历
    根节点在第二个遍历, 顺序为 左->中->右
    遍历的方法是: 递归法 + 迭代法
后续遍历
    根节点最后遍历, 顺序为 左->右->中
    遍历的方法是: 递归法 + 迭代法
```
例子如下:
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806191109896.png)
- 由于`栈其实就是递归的一种实现结构`，故前中后序遍历的逻辑其实都是可以**借助栈使用递归的方式来实现的**。

递归法参考: [二叉树的深度优先遍历-递归法](../../如何写好递归.md)
迭代法参考: [二叉树的深度优先遍历-迭代法](./traversal/深度优先遍历/二叉树深度优先遍历_迭代法的统一写法.md)

### 广度优先遍历
广度优先遍历一般指的是`层次遍历`, 使用的是`迭代法`.
- 一般借助`队列`来实现

## 二叉树的定义的代码实现
用数组的方式没什么特别的, 就按照`第i个节点的左孩子是2*i+1, 右孩子是2*i+2`的方式来实现就可以了.

二叉树的链式存储与链表的实现基本一致, 都是基于`节点结构体`进行定义的, 如下
```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 构造函数
}
```


# 一些小技巧
- 如果需要实现`从下往上遍历`或者称为`回溯`的方式去处理二叉树（这种情况一般是求**深度**，深度指的是从根节点到目标节点的距离），那么遍历顺序非常有可能是`后序遍历`，因为后序遍历的方式是`左右中`，中间节点是最后处理的，而此时中间节点恰好位于**上一层**，因此，后序遍历是进行回溯的一个非常好的选择。

- 如果要实现`从上往下`的处理顺序（一般是求**高度**，高度指的是从当前节点到叶子节点的距离），那么遍历顺序大概率是`前序遍历`，因为前序遍历的方式是`中左右`，中间节点是最先处理的。

- 如果我们遍历的二叉树是`一颗二叉搜索树`，如果要利用它**有序的特性**，那么遍历顺序大概率就是`中序遍历（左中右）`，中序遍历二叉搜索树等价于遍历一个**有序数组**。


---
# 经典问题手撕代码

## 二叉树的深度优先遍历
- [x] 前序遍历 （中-左-右）
```cpp
// 递归 (主函数需另外写)
vector<int> res;
void traversal(TreeNode* root)
{
  if(!root){
    return;
  }
  res.push_back(root->val);  // 中
  traversal(root->left);     // 左
  traversal(root->right);    // 右
}

// 迭代
void traversal(TreeNode* root)
{
  vector<int> res;
  if(!root){
    return res;
  }
  
  stack<TreeNode*> st;
  st.push(root);

  while(!st.empty()){
    TreeNode * cur = st.top();
    st.pop();
    res.push_back(cur->val);    // 中
    
    if(cur->right){
      st.push(cur->right);      // 右（因为用了栈，故right先入栈）
    }
    if(cur->left){
      st.push(cur->left)        // 左
    }
  }
  return res;
}

```


- [x] 中序遍历 （左-中-右）
```cpp

// 递归 (主函数需另外写)
vector<int> res;
void traversal(TreeNode* root)
{
  if(!root){
    return;
  }
  traversal(root->left);     // 左
  res.push_back(root->val);  // 中
  traversal(root->right);    // 右
}

// 迭代
void travesal(TreeNode* root)
{
  vector<int> res;
  TreeNode* cur = root;
  stack<TreeNode*> st;

  while(!cur || !st.empty()){
    if(!cur){
      st.push(cur);
      cur = cur->left; // 左 （右也是这里入栈）
    }
    else{
      cur = st.top();  // 拿出栈内节点（最开始拿到的是最左侧节点）
      st.pop();
      res.push_back(cur->val); // 中
      cur = cur->right; // 右
    }
  }
  return res;
}
```

- [x] 后续遍历（左-右-中）

```cpp
// 递归 (主函数需另外写)
vector<int> res;
void traversal(TreeNode* root)
{
  if(!root){
    return;
  }

  traversal(root->left);  // 左
  traversal(root->right); // 右
  res.push_back(root->val); // 中
}


// 迭代 (调整前序遍改成 中-右-左，然后将结果逆序即可)
void traversal(TreeNode* root)
{
  vector<int> res;
  if(!root){
    return res;
  }
  stack<TreeNode*> st;
  st.push(root);

  while(!st.empty()){
    TreeNode * cur = st.top();
    st.pop();
    res.push_back(cur->val);  // 中

    if(cur->left){            // 左 （注意这是入栈，需要逆序）
      st.push(cur->left);
    }
    if(cur->right){           // 右
      res.push(cur->right);
    }
  }

  reverse(res.begin(), res.end());

  return res;
}
```


