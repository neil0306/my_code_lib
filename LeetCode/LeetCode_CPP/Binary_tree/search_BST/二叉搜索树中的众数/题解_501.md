# 题目
LeetCode 501: 二叉搜索树中的众数
- https://leetcode.cn/problems/find-mode-in-binary-search-tree/


Find Mode in Binary Search Tree

Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:

1. The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.
2. The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.
3. Both the left and right subtrees must also be binary search trees.


Example 1:
![](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)

>Input: root = [1,null,2,2]
Output: [2]

Example 2:

>Input: root = [0]
Output: [0]


Constraints:

>The number of nodes in the tree is in the range [1, 10^4].
-10^5 <= Node.val <= 10^5


Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).


## 思路
- 二叉搜索树的`中序遍历`得到的结果才是是有序的！

核心思路：
- 使用双指针，一个指针指向当前节点，另一个指针指向前一个节点。
- 每次遍历节点的时候，需要维护一个`全局变量count` 变量，用于统计当前出现的节点值的次数。
- 如果 `count` 与 `另一个全局变量maxCount` 相等，说明**当前节点值出现的次数与之前的众数相等**，将当前节点值加入到结果数组中。
- 【关键】当 count > maxCount 时，说明**当前节点值出现的次数比之前的众数还多**，此时需要**清空结果数组**，然后将当前节点值加入到结果数组中。
  - 这一步重新刷新了众数的结果，使得我们遍历一次二叉树就能得到最终的结果。

## 代码
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    vector<int> res;    // 记录众数
    int count = 1;      // 记录当前节点值出现的次数
    int maxCount = 0;   // 记录当前众数的出现次数
    TreeNode * pre = nullptr; // 记录前一个节点
public:
    void traversal(TreeNode * cur)
    {
        // 递归终止条件
        if(!cur){
            return;
        }

        // 单次递归逻辑
        traversal(cur->left);       // 左

        // 中 （双指针）
        if(!pre){  // 空指针时
            count = 1;
        }
        else if (pre->val == cur->val){
            count++;
        }
        else{       // cur 与 pre 不相等，出现新的元素
            count = 1;
        }
        pre = cur;  // 更新 pre

        if(count == maxCount){      // 处理(可能存在的)重复众数
            res.push_back(cur->val); 
        }
        else if (count > maxCount){ // 处理新众数
            maxCount = count;
            res.clear();
            res.push_back(cur->val);
        }

        traversal(cur->right);      // 右
    }

    vector<int> findMode(TreeNode* root) {
        traversal(root);
        return res;
    }
};
```

