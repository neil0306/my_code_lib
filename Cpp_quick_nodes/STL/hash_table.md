# 哈希表 (HashTable)

哈希表是STL中非常重要的底层结构, 诸如 `unordered_set`, `unordered_map`等无序关联容器的内部都是基于哈希表实现的.

这里主要用一个简单的哈希表实现来讲述`哈希表`, `哈希冲突`, `迭代器`, `性能优化`等方面的问题.

## 哈希表原理分析
1. 哈希表基础知识
    > 哈希表是一种`通过哈希函数将 键(key) 映射为 索引(index) 的数据结构`. 
    
    > 哈希函数负责将任意大小的输入映射到固定大小的输出, 即哈希值. 哈希值用作数组中关联 key-value 的索引.

2. 哈希冲突
    > 由于哈希函数的映射不是一对一的, 可能会`存在两个不同的key映射为同一个index的情况`, 这就是哈希冲突.

    > 哈希冲突可以使用`链地址法`来解决, 即在哈希表的每一个 bucket 中维护一个链表, 将哈希值相同的元素存储在同一个 bucket 的链表中.

3. 哈希表的扩容与 **rehashing**
   > 为了避免哈希表中链表过长导致的性能下降, 通常会在需要时对哈希表进行扩容.

   > 扩容的过程涉及`重新计算所有元素的哈希值`, 并将他们分布到新的更大的哈希表中. 这个过程就称为**rehashing**.

4. 性能优化
   > 为了提高性能, 哈希表的实现通常包含一系列优化策略, 比如: 使用`二次哈希函数`, `空间配置器`, `内存池`等等, 以减少内存分配的开销, 提高访问速度.

5. 并发性与多线程安全性
    > 在多线程环境中, 确保数据结构的正确性至关重要.
    
    > 多线程哈希表的视线通常需要考虑并发性和多线程安全性, 通过`锁`或者其他机制来保护共享的数据结构.

    - 下图是一个哈希表的插入元素的例子:
    ![](hash_table_images/哈希表中插入元素的过程.png)
      - 上述过程中, 假设每个bucket链表长度大于1就开始rehash
      - 可以看到, 每个bucket用一个链表来存储重复的元素, 如8和17



